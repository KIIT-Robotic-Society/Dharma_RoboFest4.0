/*
--------------------------xxxxxxxxxxxxxxxxxx--------------------------
Sensors includes,
1. MPU Data
2. Pulse Meter Data
3. GPS data

Take 5 reading of the data, and store all in the Link list
also called as the base reading

Make the Mode selection null and Flag as 0 or false
--------------------------xxxxxxxxxxxxxxxxxx--------------------------
Task 1: This Task handles the Hardware Interrupts 

This task maintains the button interrupt 
up_button
down_button
select button
press_button
--------------------------xxxxxxxxxxxxxxxxxx--------------------------
Task 2: It reads the sensors and stores in the Link List

Data sources:
- Pulse Meter: pulsemeter_read() -> stores in the link list
- GPS Data: gps_read() -> retrieves GPS information
- MPU Data: read_MPUData() -> retrieves the MPU Data

--------------------------xxxxxxxxxxxxxxxxxx--------------------------
Task 3: Prepares data to send to ESP-NOW using Queues

It reads the MPU data, GPS data, Pulse data, Failsafe flag, ADC Value
and dog_mode and convert to one String, and sent it to the Queue.
--------------------------xxxxxxxxxxxxxxxxxx--------------------------
Task 4: Sending data through ESP-NOW

The data in the Queue is sent to the receiver ESP using ESP-NOW
--------------------------xxxxxxxxxxxxxxxxxx--------------------------
--------------------------xxxxxxxxxxxxxxxxxx--------------------------
Task 5: OLED GUI Handling

It handles the OLED GUI, as per the volatile values changed by the 
hardware Interrupts.
--------------------------xxxxxxxxxxxxxxxxxx--------------------------
--------------------------xxxxxxxxxxxxxxxxxx--------------------------
Task 6: Retreives the Data

Premptative Task
--------------------------xxxxxxxxxxxxxxxxxx--------------------------
--------------------------xxxxxxxxxxxxxxxxxx--------------------------
Task 7: FailSafe Mode

To check the device is in failsafe or not, it checks the MPU data 
from the link list, and compare the first values to the other, if it 
is stable, accordingto the tolerance value, it checks the pulse meter
sensor data, it it is abnormal, it delete task except th esp now handler,
and it switches to failsafew mode 
--------------------------xxxxxxxxxxxxxxxxxx--------------------------
Task 8: FailSafe Trigger GUI
It delete the other tasks, and handles the GUI in case of FailSafe
--------------------------xxxxxxxxxxxxxxxxxx--------------------------

**PINS***

--GPS--
Vcc->3.3V
Gnd->Gnd
Tx->D3
Rx->D2

--MAX30102--
Vcc->3.3V
Gnd->Gnd
SDA->D4
SCL->D5/Users/arkabanerjee/Documents/watch_dog.txt

--MPU--
Vcc->3.3V
Gnd->Gnd
SDA->D4
SCL->D5

--OLED--
Vcc->3.3V
Gnd->Gnd
SDA->D4
SCL->D5

--buttons--
up_button->D10
down_button->D9
select_button->D8
press_button->D0

--Voltage Divider--
R1=10K
R2=1K
ADC->D1

--------------------------xxxxxxxxxxxxxxxxxx--------------------------*/

//The mac address of the receiver ESP is 64:e8:33:7f:83:8c
//and this esp is 48:27:e2:e7:1d:74

/* Header Files */
#include <Wire.h> //I2C header file
#include <Adafruit_GFX.h> //adafruit GUI header
#include <Adafruit_SSD1306.h> //adafruit oled header
#include <MPU6050.h> //MEMS Acc,Gyro Header
#include <esp_now.h> //ESP NOW header
#include <WiFi.h> //WIFI Mode header
#include <SoftwareSerial.h> //softserail for UART
#include <TinyGPS.h> //GPS header
#include <freertos/FreeRTOS.h>//RTOS
#include <freertos/task.h>//tasks
#include <MAX30105.h>//pulse meter sensor
#include <heartRate.h>
#include <string.h>
#include <EEPROM.h>

//screen ratio used
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64

esp_now_peer_info_t peerInfo;

//declaration 
MAX30105 particleSensor;
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);
TinyGPS gps;
MPU6050 mpu;
SoftwareSerial mySerial(D3, D2);  // RX, TX for GPS UART


//RTOS UNICORE/MULTICORE Declaration
#if CONFIG_FREERTOS_UNICORE
  #define ARDUINO_RUNNING_CORE 0  // Core 0 
#else
  #define ARDUINO_RUNNING_CORE 1  // Core 1 
#endif

/* check the MAC Adress using the ESP_MAC_Address.ino file */
uint8_t broadcastAddress[] = {0x34, 0xB7, 0xDA, 0x68, 0xBE, 0x30};


//heartbeat GUI bitmap
static const uint8_t heartbeat_GUI[1024] = {
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
	0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 
	0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
	0x40, 0xff, 0xe0, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 
	0x40, 0x80, 0x20, 0x00, 0x00, 0x03, 0x30, 0x01, 0x83, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
	0x40, 0xb6, 0x30, 0x00, 0x00, 0x03, 0x31, 0xe3, 0xe7, 0xc7, 0x8c, 0xcc, 0xc0, 0x00, 0x00, 0x42, 
	0x40, 0xb6, 0x30, 0x00, 0x00, 0x03, 0x33, 0x31, 0x83, 0x0c, 0xcd, 0xcc, 0xc0, 0x00, 0x00, 0x40, 
	0x40, 0xb6, 0x30, 0x00, 0x00, 0x03, 0xe0, 0x31, 0x83, 0x0c, 0xce, 0x0c, 0xc0, 0x00, 0x00, 0x42, 
	0x40, 0xb6, 0x30, 0x00, 0x00, 0x03, 0x31, 0xf1, 0x83, 0x0f, 0xcc, 0x0c, 0xc0, 0x00, 0x00, 0x40, 
	0x40, 0x80, 0x20, 0x00, 0x00, 0x03, 0x33, 0x31, 0x83, 0x0c, 0x0c, 0x0c, 0xc0, 0x00, 0x00, 0x42, 
	0x40, 0xff, 0xe0, 0x00, 0x00, 0x03, 0x33, 0x31, 0x83, 0x0c, 0xcc, 0x07, 0xc0, 0x00, 0x00, 0x40, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe1, 0xf0, 0xe1, 0xc7, 0x8c, 0x00, 0xc0, 0x00, 0x00, 0x42, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0xc0, 0x00, 0x00, 0x40, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x42, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 
	0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x02, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 
	0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 
	0xdf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7d, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbd, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbd, 
	0xbf, 0xc7, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 
	0xbf, 0xba, 0xef, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbd, 
	0xbf, 0x7d, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 
	0xbe, 0xff, 0xfb, 0xff, 0xff, 0x33, 0xff, 0xff, 0xff, 0xfe, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xbd, 
	0xbe, 0xfe, 0xfb, 0xff, 0xff, 0x33, 0xff, 0xff, 0xff, 0x9e, 0x67, 0xff, 0xff, 0x3f, 0xff, 0xbf, 
	0xbe, 0xdd, 0x7b, 0xff, 0xff, 0x33, 0x87, 0x87, 0x33, 0x06, 0x67, 0x0f, 0x0e, 0x0f, 0xff, 0xbd, 
	0xb0, 0x2b, 0x80, 0x3f, 0xff, 0x33, 0x33, 0x33, 0x23, 0x9e, 0x66, 0x66, 0x67, 0x3f, 0xff, 0xbf, 
	0xbf, 0x77, 0xf7, 0xff, 0xff, 0x03, 0x33, 0xf3, 0x1f, 0x9e, 0x0e, 0x67, 0xe7, 0x3f, 0xff, 0xbd, 
	0xbf, 0xbf, 0xef, 0xff, 0xff, 0x33, 0x03, 0x83, 0x3f, 0x9e, 0x66, 0x07, 0x07, 0x3f, 0xff, 0xbf, 
	0xbf, 0xdf, 0xdf, 0xff, 0xff, 0x33, 0x3f, 0x33, 0x3f, 0x9e, 0x66, 0x7e, 0x67, 0x3f, 0xff, 0xbd, 
	0xbf, 0xef, 0xbf, 0xff, 0xff, 0x33, 0x33, 0x33, 0x3f, 0x9e, 0x66, 0x66, 0x67, 0x3f, 0xff, 0xb8, 
	0xbf, 0xf7, 0x7f, 0xff, 0xff, 0x33, 0x87, 0x83, 0x3f, 0xc6, 0x0f, 0x0f, 0x07, 0x8f, 0xff, 0xb8, 
	0xbf, 0xfa, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb8, 
	0xbf, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb8, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb8, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb8, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb8, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb8, 
	0xdf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x78, 
	0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8
};

//GPS GUI bitmap
static const uint8_t gps_GUI[1024] = {
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 
	0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x87, 
	0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 
	0x40, 0x20, 0x40, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 
	0x40, 0x10, 0x80, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 
	0x40, 0x1f, 0x80, 0x00, 0x00, 0x00, 0xc0, 0xf8, 0x78, 0xec, 0x66, 0x00, 0x00, 0x00, 0x00, 0x22, 
	0x40, 0x3f, 0xc0, 0x00, 0x00, 0x00, 0xc0, 0xcc, 0xcc, 0xd6, 0x66, 0x00, 0x00, 0x00, 0x00, 0x20, 
	0x40, 0x76, 0xe0, 0x00, 0x00, 0x00, 0xf0, 0xcc, 0xcc, 0xd6, 0x66, 0x00, 0x00, 0x00, 0x00, 0x22, 
	0x40, 0x5f, 0xa0, 0x00, 0x00, 0x00, 0xc0, 0xcc, 0xfc, 0xd6, 0x66, 0x00, 0x00, 0x00, 0x00, 0x20, 
	0x40, 0x50, 0xa0, 0x00, 0x00, 0x00, 0xc0, 0xcc, 0xc0, 0xd6, 0x66, 0x00, 0x00, 0x00, 0x00, 0x22, 
	0x40, 0x19, 0x80, 0x00, 0x00, 0x00, 0xc0, 0xcc, 0xcc, 0xc6, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x20, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xcc, 0x78, 0xc6, 0x06, 0x00, 0x00, 0x00, 0x00, 0x22, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x00, 0x00, 0x00, 0x00, 0x20, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x22, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 
	0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
	0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x82, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 
	0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 
	0xdf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbd, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdd, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdd, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 
	0xbf, 0xe0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdd, 
	0xbf, 0xdf, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 
	0xbf, 0xb0, 0xdf, 0xff, 0xff, 0xff, 0xff, 0xc3, 0x83, 0xc3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdd, 
	0xbf, 0xaf, 0x5f, 0xff, 0xff, 0xff, 0xff, 0x99, 0x99, 0x99, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 
	0xbf, 0xaf, 0x5f, 0xff, 0xff, 0xff, 0xff, 0x9f, 0x99, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdd, 
	0xbf, 0xaf, 0x5f, 0xff, 0xff, 0xff, 0xff, 0x9f, 0x99, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 
	0xbf, 0xaf, 0x5f, 0xff, 0xff, 0xff, 0xff, 0x91, 0x83, 0xc3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdd, 
	0xbf, 0xb0, 0xdf, 0xff, 0xff, 0xff, 0xff, 0x99, 0x9f, 0xf9, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 
	0xbf, 0xdf, 0xbf, 0xff, 0xff, 0xff, 0xff, 0x99, 0x9f, 0xf9, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdd, 
	0xbf, 0xef, 0x7f, 0xff, 0xff, 0xff, 0xff, 0x99, 0x9f, 0x99, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 
	0xbf, 0xf6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc1, 0x9f, 0xc3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdd, 
	0xbf, 0xf9, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 
	0xbf, 0xf9, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdd, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdd, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdd, 
	0xdf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 
	0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7d, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd
};

//enemy GUI bitmap
static const uint8_t enemy_GUI[1024] = {
 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 
	0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 
	0xdf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb8, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xd8, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xd8, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xd8, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xd8, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xd8, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xd8, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xd8, 
	0xbf, 0xdf, 0xbf, 0xff, 0xff, 0xff, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xd8, 
	0xbf, 0xef, 0x7f, 0xff, 0xff, 0xff, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 
	0xbf, 0xe0, 0x7f, 0xff, 0xff, 0xff, 0x3f, 0x07, 0x87, 0x13, 0x99, 0xff, 0xff, 0xff, 0xff, 0xdd, 
	0xbf, 0xc0, 0x3f, 0xff, 0xff, 0xff, 0x3f, 0x33, 0x33, 0x29, 0x99, 0xff, 0xff, 0xff, 0xff, 0xdf, 
	0xbf, 0x89, 0x1f, 0xff, 0xff, 0xff, 0x0f, 0x33, 0x33, 0x29, 0x99, 0xff, 0xff, 0xff, 0xff, 0xdd, 
	0xbf, 0xa0, 0x5f, 0xff, 0xff, 0xff, 0x3f, 0x33, 0x03, 0x29, 0x99, 0xff, 0xff, 0xff, 0xff, 0xdf, 
	0xbf, 0xaf, 0x5f, 0xff, 0xff, 0xff, 0x3f, 0x33, 0x3f, 0x29, 0x99, 0xff, 0xff, 0xff, 0xff, 0xdd, 
	0xbf, 0xe6, 0x7f, 0xff, 0xff, 0xff, 0x3f, 0x33, 0x33, 0x39, 0xc1, 0xff, 0xff, 0xff, 0xff, 0xdf, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x33, 0x87, 0x39, 0xf9, 0xff, 0xff, 0xff, 0xff, 0xdd, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x99, 0xff, 0xff, 0xff, 0xff, 0xdf, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc3, 0xff, 0xff, 0xff, 0xff, 0xdd, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdd, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdd, 
	0xdf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 
	0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7d, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
	0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 
	0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 
	0x40, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 
	0x40, 0x20, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 
	0x40, 0x4f, 0x20, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x7c, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 
	0x40, 0x50, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 
	0x40, 0x50, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x60, 0x66, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 
	0x40, 0x50, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x60, 0x66, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 
	0x40, 0x50, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x6e, 0x7c, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 
	0x40, 0x4f, 0x20, 0x00, 0x00, 0x00, 0x00, 0x66, 0x60, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 
	0x40, 0x20, 0x40, 0x00, 0x00, 0x00, 0x00, 0x66, 0x60, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 
	0x40, 0x10, 0x80, 0x00, 0x00, 0x00, 0x00, 0x66, 0x60, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 
	0x40, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x60, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 
	0x40, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 
	0x40, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 
	0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
	0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x82, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02
};

//battery GUI bitmap
static const uint8_t battery_GUI[1024] = {
 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 
	0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 
	0xdf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7d, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbd, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbd, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbd, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 
	0xbf, 0x00, 0x1f, 0xff, 0xff, 0xfc, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbd, 
	0xbf, 0x7f, 0xdf, 0xff, 0xff, 0xfc, 0xcf, 0xfe, 0x7c, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 
	0xbf, 0x49, 0xcf, 0xff, 0xff, 0xfc, 0xce, 0x1c, 0x18, 0x38, 0x73, 0x33, 0x3f, 0xff, 0xff, 0xbd, 
	0xbf, 0x49, 0xcf, 0xff, 0xff, 0xfc, 0xcc, 0xce, 0x7c, 0xf3, 0x32, 0x33, 0x3f, 0xff, 0xff, 0xbf, 
	0xbf, 0x49, 0xcf, 0xff, 0xff, 0xfc, 0x1f, 0xce, 0x7c, 0xf3, 0x31, 0xf3, 0x3f, 0xff, 0xff, 0xbd, 
	0xbf, 0x49, 0xcf, 0xff, 0xff, 0xfc, 0xce, 0x0e, 0x7c, 0xf0, 0x33, 0xf3, 0x3f, 0xff, 0xff, 0xbf, 
	0xbf, 0x7f, 0xdf, 0xff, 0xff, 0xfc, 0xcc, 0xce, 0x7c, 0xf3, 0xf3, 0xf3, 0x3f, 0xff, 0xff, 0xbd, 
	0xbf, 0x00, 0x1f, 0xff, 0xff, 0xfc, 0xcc, 0xce, 0x7c, 0xf3, 0x33, 0xf8, 0x3f, 0xff, 0xff, 0xbf, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x1e, 0x0f, 0x1e, 0x38, 0x73, 0xff, 0x3f, 0xff, 0xff, 0xbd, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x3f, 0xff, 0xff, 0xbf, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x7f, 0xff, 0xff, 0xbd, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbd, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 
	0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbd, 
	0xdf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 
	0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfd, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
	0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 
	0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 
	0x40, 0x38, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
	0x40, 0x45, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 
	0x40, 0x82, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
	0x41, 0x00, 0x04, 0x00, 0x00, 0xcc, 0x00, 0x00, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x42, 
	0x41, 0x01, 0x04, 0x00, 0x00, 0xcc, 0x00, 0x00, 0x00, 0x61, 0x98, 0x00, 0x00, 0xc0, 0x00, 0x40, 
	0x41, 0x22, 0x84, 0x00, 0x00, 0xcc, 0x78, 0x78, 0xcc, 0xf9, 0x98, 0xf0, 0xf1, 0xf0, 0x00, 0x42, 
	0x4f, 0xd4, 0x7f, 0xc0, 0x00, 0xcc, 0xcc, 0xcc, 0xdc, 0x61, 0x99, 0x99, 0x98, 0xc0, 0x00, 0x40, 
	0x40, 0x88, 0x08, 0x00, 0x00, 0xfc, 0xcc, 0x0c, 0xe0, 0x61, 0xf1, 0x98, 0x18, 0xc0, 0x00, 0x42, 
	0x40, 0x40, 0x10, 0x00, 0x00, 0xcc, 0xfc, 0x7c, 0xc0, 0x61, 0x99, 0xf8, 0xf8, 0xc0, 0x00, 0x40, 
	0x40, 0x20, 0x20, 0x00, 0x00, 0xcc, 0xc0, 0xcc, 0xc0, 0x61, 0x99, 0x81, 0x98, 0xc0, 0x00, 0x42, 
	0x40, 0x10, 0x40, 0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xc0, 0x61, 0x99, 0x99, 0x98, 0xc0, 0x00, 0x47, 
	0x40, 0x08, 0x80, 0x00, 0x00, 0xcc, 0x78, 0x7c, 0xc0, 0x39, 0xf0, 0xf0, 0xf8, 0x70, 0x00, 0x47, 
	0x40, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 
	0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 
	0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87, 
	0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x07, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07
};

//----------------Global Variable Declaration----------------------------

//Buttons
#define up_button D10
#define down_button D9
#define select_button D0
#define press_button D8

const int ADC = D1;//ADC

//Acceleration & Gyro Declation
int16_t accX, accY, accZ; // Accelerometer raw data
int16_t gyroX, gyroY, gyroZ; // Gyroscope raw data
double roll, pitch, yaw; // Angle values
double kalmanX, kalmanY; // Kalman filter outputs

// Kalman filter variables
double q_angle = 0.001; // Process noise variance for the accelerometer
double q_bias = 0.003;  // Process noise variance for the gyro
double r_measure = 0.03; // Measurement noise variance

double angleX = 0; // Kalman angle
double angleY = 0; // Kalman angle
double biasX = 0; // Bias
double biasY = 0; // Bias

//Flags
unsigned volatile static int GUI_mode=1;
volatile bool flag_GUI=false;
volatile bool select_flag=false;
volatile bool press_flag = false;
volatile bool Failsafe_mode=false;
bool isDecrementing = false; 
volatile bool failsafe_bool=false;
volatile bool enter_flag=false;

//Dog mode
volatile int dog_mode = 1; 
volatile int mode_remote=-1;

//received data
int remotebattery=-1;
int Pocbattery=-1;
int enemy_detected=-1; 

//RTOS
volatile BaseType_t xHigherPriorityTaskWoken = pdFALSE; // Indicates if a higher priority task was woken
volatile int interruptCounter = 0; // Variable to count interrupts
int min_x;

//trash varaibles
float batteryVoltage;
String percentage;
float vRef = 3.3;  
float vMax = 4.2;  
volatile float batteryPercentage=0; 


//ESP-NOW variables
const char* success;
//String incomingReadings;
#define MAX_DATA_LENGTH 50 // Adjust as needed for your string size

//debouncing effect Delays
unsigned long lastDebounceTime_upbutton = 0;
unsigned long lastDebounceTime_downbutton = 0;
unsigned long lastDebounceTime = 0; 
const unsigned long debounceDelay = 200;
unsigned long lastTime;
double dt;

//MAX10302 Variables
const int MAX_LIST_SIZE = 5;  // Maximum size of the linked list     
int currentListSize = 0;      // Current size of the linked list

// Variables to store BPM data
const byte RATE_SIZE = 4; //Increase this for more averaging. 4 is good.
byte rates[RATE_SIZE]; //Array of heart rates
byte rateSpot = 0;
long lastBeat = 0; //Time at which the last beat occurred
float beatsPerMinute;
int beatAvg;

//buffer
const int buffer_time=5000;//for taking default reading from MAX10302


//--------------------------xxxxxxxxxxxxxxxxx------------------------------


//----------------------------HEARTRATE SENSOR-----------------------------
struct Node_heartrate {
  String irValue;             
  String bpm;                
  String avgBpm;               
  Node_heartrate* next;        
};


Node_heartrate* head_heartrate = NULL;

void addHeartrateNode(String irValue, String bpm, String avgBpm) {

  Node_heartrate* newNode = new Node_heartrate();
  newNode->irValue = irValue;    
  newNode->bpm = bpm;            
  newNode->avgBpm = avgBpm;      
  newNode->next = head_heartrate; 
  head_heartrate = newNode;       

  currentListSize++;

  if (currentListSize > MAX_LIST_SIZE) {

    Node_heartrate* temp = head_heartrate;
    
    if (temp != NULL && temp->next != NULL) {
      while (temp->next->next != NULL) {
        temp = temp->next;
      }

      delete temp->next;
      temp->next = NULL;
      currentListSize--;
    } else {

      delete head_heartrate;
      head_heartrate = NULL; 
      currentListSize = 0; 
    }
  }
}


// Function to get IR value
String getIRValue(int nodeNumber) {
  Node_heartrate* current = head_heartrate;
  int count = 0;
  
  while (current != NULL) {
    if (count == nodeNumber) {
      return current->irValue;  
    }
    count++;
    current = current->next;
  }
  
  return "Invalid Node"; 
}

// Function to get BPM 
String getBPM(int nodeNumber) {
  Node_heartrate* current = head_heartrate;
  int count = 0;

  while (current != NULL) {
    if (count == nodeNumber) {
      return current->bpm;  
    }
    count++;
    current = current->next;
  }
  return "Invalid Node"; 
}

// Function to get Avg BPM 
String getAvgBPM(int nodeNumber) {
  Node_heartrate* current = head_heartrate;
  int count = 0;

  while (current != NULL) {
    if (count == nodeNumber) {
      return current->avgBpm;  
    }
    count++;
    current = current->next;
  }

  return "Invalid Node";  
}

//--------------------------xxxxxxxxxxxxxxxxx------------------------------


//----------------------------GPS SENSOR------------------------------------

struct Node_GPS {
    String gpsData; 
    Node_GPS* next;   
};

Node_GPS* head_GPS = nullptr;
Node_GPS* tail_GPS = nullptr;
const int maxNodes_GPS = 5; 
int nodeCount_GPS = 0;  


void addNode_GPS(String gpsData) {
    Node_GPS* newNode = new Node_GPS();
    newNode->gpsData = gpsData;
    newNode->next = nullptr;

    if (nodeCount_GPS < maxNodes_GPS) {
        if (head_GPS == nullptr) {
            head_GPS = newNode; 
            tail_GPS = newNode;
        } else {
            tail_GPS->next = newNode;
            tail_GPS = newNode;
        }
        nodeCount_GPS++;
    } else {
        Node_GPS* temp = head_GPS;
        head_GPS = head_GPS->next;
        temp->gpsData = gpsData;
        tail_GPS->next = temp; 
        tail_GPS = temp;
        tail_GPS->next = nullptr; 
    }
}

// Function to get latitude 
String getLatitude(int nodeNum) {
    Node_GPS* current = head_GPS;
    int count = 0;

    while (current != nullptr) {
        if (count == nodeNum) {
            int latIndex = current->gpsData.indexOf(',');
            if (latIndex != -1) {
                return current->gpsData.substring(0, latIndex); 
            }
            break; 
        }
        current = current->next;
        count++;
    }
    return "none"; 
}

// Function to get longitude 
String getLongitude(int nodeNum) {
    Node_GPS* current = head_GPS;
    int count = 0;

    while (current != nullptr) {
        if (count == nodeNum) {
            int latIndex = current->gpsData.indexOf(',');
            int longIndex = current->gpsData.indexOf(',', latIndex + 1);
            if (longIndex != -1) {
                return current->gpsData.substring(latIndex + 1, longIndex); 
            }
            break; 
        }
        current = current->next;
        count++;
    }
    return "none"; 
}

// Function to get Satellite Count
String getSatelliteCount(int nodeNum) {
    Node_GPS* current = head_GPS;
    int count = 0;

    while (current != nullptr) {
        if (count == nodeNum) {
            int longIndex = current->gpsData.lastIndexOf(',');
            if (longIndex != -1) {
                return current->gpsData.substring(longIndex + 1); 
            }
            break;
        }
        current = current->next;
        count++;
    }
    return "none";
}
//--------------------------xxxxxxxxxxxxxxxxx------------------------------


//----------------------------MPU SENSOR------------------------------------

struct Node_MPU {
    String data_MPU;
    Node_MPU* next_MPU;
};

Node_MPU* findNode(int position);

Node_MPU* head_MPU = nullptr;
Node_MPU* tail_MPU = nullptr;

int nodeCount_MPU = 0;         
const int maxNodes_MPU = 5;  

void addNode_MPU(String pitchRollYawData) {

    if (nodeCount_MPU < maxNodes_MPU) {
        Node_MPU* newNode = new Node_MPU(); 
        newNode->data_MPU = pitchRollYawData;
        newNode->next_MPU = nullptr;

        if (head_MPU == nullptr) {
            head_MPU = newNode;
            tail_MPU = newNode;
        } 
        else {
            tail_MPU->next_MPU = newNode;
            tail_MPU = newNode; 
        }
        nodeCount_MPU++;
    } 
    else {
        Node_MPU* temp = head_MPU; 
        head_MPU = head_MPU->next_MPU; 
        temp->data_MPU = pitchRollYawData;
        tail_MPU->next_MPU = temp;
        tail_MPU = temp;
        tail_MPU->next_MPU = nullptr;
    }
}

//finding node position
Node_MPU* findNode(int position) {
    Node_MPU* current = head_MPU;
    int count = 1;

    while (current != nullptr && count < position) {
        current = current->next_MPU;
        count++;
    }
    return current;  
}

//get pitch value 
String getPitchValue(int position) {
    Node_MPU* node = findNode(position);
    if (node != nullptr) {
        int pitchPos = node->data_MPU.indexOf("Pitch: ") + 7; 
        String pitchValue = node->data_MPU.substring(pitchPos, node->data_MPU.indexOf(",", pitchPos));
        return pitchValue;
    } else {
        return "Node does not exist";
    }
}

//get roll value
String getRollValue(int position) {
    Node_MPU* node = findNode(position);
    if (node != nullptr) {
        int rollPos = node->data_MPU.indexOf("Roll: ") + 6; 
        String rollValue = node->data_MPU.substring(rollPos, node->data_MPU.indexOf(",", rollPos));
        return rollValue;
    } else {
        return "Node does not exist";
    }
}

//get Yaw value
String getYawValue(int position) {
    Node_MPU* node = findNode(position);
    if (node != nullptr) {
        int yawPos = node->data_MPU.indexOf("Yaw: ") + 5; 
        String yawValue = node->data_MPU.substring(yawPos);
        return yawValue;
    } else {
        return "Node does not exist";
    }
}

//calculation of rawdata to PitchRollYaw
void calculatePitchRollYaw(int16_t gyroX, int16_t gyroY, int16_t gyroZ, float &pitch, float &roll, float &yaw) {
    pitch = atan(gyroX / sqrt(gyroY * gyroY + gyroZ * gyroZ)) * 180 / PI;
    roll = atan(gyroY / sqrt(gyroX * gyroX + gyroZ * gyroZ)) * 180 / PI;
    yaw = atan(gyroZ / sqrt(gyroX * gyroX + gyroY * gyroY)) * 180 / PI;
}

//--------------------------xxxxxxxxxxxxxxxxx------------------------------


//----------------------------ESP-NOW---------------------------


//Receiving data
String receivedData;

#define QUEUE_SIZE 5
QueueHandle_t dataQueue;
String sendData;

// Callback function when data is sent
void OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status) {
    Serial.print("\r\nLast Packet Send Status:\t");
    Serial.println(status == ESP_NOW_SEND_SUCCESS ? "Delivery Success" : "Delivery Fail");
}

// Callback when data is received
void onDataReceived(const esp_now_recv_info *info, const uint8_t *data, int len) {
    receivedData = "";
    receivedData.reserve(len + 1);
    receivedData += (const char *)data; 

    // Print received data for debugging
    //Serial.print("Received data: ");
    //Serial.println(receivedData);

    // Parse the incoming string

    // Split the string by comma
    char *token = strtok(const_cast<char *>(receivedData.c_str()), ",");
    if (token != NULL) {
        mode_remote = atoi(token); // Convert mode to int
        token = strtok(NULL, ",");
    }
    
    if (token != NULL) {
        remotebattery= atoi(token); // Convert remote battery to int
        token = strtok(NULL, ",");
    }

    if (token != NULL) {
        Pocbattery = atoi(token); // Convert POC battery to int
        token = strtok(NULL, ",");
    }

    if (token != NULL) {
        enemy_detected = atoi(token); // Convert POC battery to int
        token = strtok(NULL, ",");
    }

    yield();
    // Print parsed data
    /*Serial.print("Mode: "); Serial.println(mode);
    Serial.print("Remote Battery: "); Serial.println(remoteBatteryPercentage);
    Serial.print("POC Battery: "); Serial.println(pocBatteryPercentage);
    Serial.print("Emery Detected: "); Serial.println(enemy);*/
}


//--------------------------xxxxxxxxxxxxxxxxx------------------------------


//----------------------------ISR Functions---------------------------

//ISR up button
void IRAM_ATTR up_ISR() {

  if(Failsafe_mode==false && failsafe_bool==false){ //checls the failsafe mode
  interruptCounter++; 

  unsigned long currentTime = millis();

  if ((currentTime - lastDebounceTime_upbutton) > debounceDelay) {
  GUI_mode++;

  if(GUI_mode>4){
    GUI_mode=4;
  }

  if(GUI_mode<1){
    GUI_mode=1;
  }

  flag_GUI=true;
  lastDebounceTime_upbutton = currentTime;
  }
  xHigherPriorityTaskWoken = pdTRUE; 
  }
}

//ISR down button
void IRAM_ATTR down_ISR() {

  if(Failsafe_mode==false && failsafe_bool==false){ //checls the failsafe mode
  interruptCounter++;
  unsigned long currentTime = millis();
  if ((currentTime - lastDebounceTime_downbutton) > debounceDelay) {
    GUI_mode--;

  if(GUI_mode>4){
    GUI_mode=4;
  }

  if(GUI_mode<1){
    GUI_mode=1;
  }
  
  flag_GUI=true;
  lastDebounceTime_downbutton = currentTime;
  }

  xHigherPriorityTaskWoken = pdTRUE; 
  }
}

//ISR select button
void IRAM_ATTR select_ISR() {

  if(Failsafe_mode==false && failsafe_bool==false){ //checls the failsafe mode
  unsigned long currentTime = millis();
  interruptCounter++; 
  if ((currentTime - lastDebounceTime_downbutton) > debounceDelay) {
  if(select_flag==true){
    select_flag=false;
  }
  else{
    select_flag=true;
  }

  xHigherPriorityTaskWoken = pdTRUE; 
  lastDebounceTime_downbutton = currentTime;
    }
  }
}

void IRAM_ATTR press_ISR() {

    if(Failsafe_mode==false && failsafe_bool==false){  //checls the failsafe mode
    unsigned long currentTime = millis();
  
    if ((currentTime - lastDebounceTime) > debounceDelay) {
        if (dog_mode < 3 && !isDecrementing) {
            dog_mode++;
        } 
        else if (dog_mode == 3 && !isDecrementing) {
            isDecrementing = true;
            dog_mode--;
        }
        else if (dog_mode > 1 && isDecrementing) {
            dog_mode--;
            if (dog_mode == 1) {
                isDecrementing = false;
            }
        }
        
        lastDebounceTime = currentTime;
    }
  }
}

//--------------------------xxxxxxxxxxxxxxxxx------------------------------

//----------------------------FreeRTOS---------------------------

TaskHandle_t Task1;
TaskHandle_t Task2;
TaskHandle_t Task3;
TaskHandle_t Task4;
TaskHandle_t Task5;
TaskHandle_t Task6;
TaskHandle_t Task7;
TaskHandle_t Task8;


//delete tasks for failsafe mode
void deleteAllTasks() {
    if (Task1 != NULL) {
        vTaskDelete(Task1);
        Task1 = NULL;
    }
    if (Task5 != NULL) {
        vTaskDelete(Task5);
        Task5 = NULL; 
    }
    if (Task6 != NULL) {
        vTaskDelete(Task6);
        Task6 = NULL; 
    }
     vTaskDelay(100 / portTICK_PERIOD_MS);
}

//Task 1->for external interrupt Handle
void task1(void *pvParameters) {
    for (;;) {
        // Check if interrupt has occurred
        if (interruptCounter > 0) {
            Serial.print("Interrupt Count: ");
            Serial.println(interruptCounter);
            interruptCounter = 0; 
        }
        vTaskDelay(100 / portTICK_PERIOD_MS);
    }
}

//Task 2->reading data from the sensors
void task2(void *pvParameters) {
  while (true) {
    //taking 5 mpu data
     for(int i = 0; i < 5; i++) {
        int16_t gyroX, gyroY, gyroZ;
        mpu.getRotation(&gyroX, &gyroY, &gyroZ); 
        float pitch, roll, yaw;
        calculatePitchRollYaw(gyroX, gyroY, gyroZ, pitch, roll, yaw);

        String pitchRollYawData = "Pitch: " + String(pitch, 2) + ", Roll: " + String(roll, 2) + ", Yaw: " + String(yaw, 2);
        addNode_MPU(pitchRollYawData);
        vTaskDelay(100 / portTICK_PERIOD_MS);
    }

    //GPS
    for(int i = 0; i < 5; i++) {
    bool newData = false;
    unsigned long start = millis();
     // For one second, we parse GPS data
  while (millis() - start < 100)
  {
    while (mySerial.available())  // Check if GPS data is available
    {
      char c = mySerial.read(); 
      if (gps.encode(c))
      {
        newData = true;
      }
    }
  }
   if (newData)
  {
    float flat, flon;
    unsigned long age;
    
    gps.f_get_position(&flat, &flon, &age);

    int sat = gps.satellites();

    // Convert latitude, longitude, and satellite count to strings
    String latitude = flat == TinyGPS::GPS_INVALID_F_ANGLE ? "INVALID" : String(flat, 6);
    String longitude = flon == TinyGPS::GPS_INVALID_F_ANGLE ? "INVALID" : String(flon, 6);
    String satellites = sat == TinyGPS::GPS_INVALID_SATELLITES ? "INVALID" : String(sat);

    // Concatenate the values into a single string in the format (latitude,longitude,satellites)
    String combinedString = "(" + latitude + "," + longitude + "," + satellites + ")";
    addNode_GPS(combinedString);
  }
  else
  {
    addNode_GPS("0,0,0");
  }
    }

  //MAX30102
   for(int i=0;i<=80;i++){
    long irValue = particleSensor.getIR();
  if (checkForBeat(irValue) == true)
  {
    long delta = millis() - lastBeat;
    lastBeat = millis();

    beatsPerMinute = 60 / (delta / 1000.0);

    if (beatsPerMinute < 255 && beatsPerMinute > 20)
    {
      rates[rateSpot++] = (byte)beatsPerMinute;
      rateSpot %= RATE_SIZE;

      beatAvg = 0;
      for (byte x = 0 ; x < RATE_SIZE ; x++)
        beatAvg += rates[x];
      beatAvg /= RATE_SIZE;
    }
  }
    addHeartrateNode(String(irValue), String(beatsPerMinute), String(beatAvg));
  }

  float vADS = ( analogRead(D1) * vRef) / 4095.0;  
  float vBattery = vADS * 11; 
  batteryPercentage= (vBattery / vMax) * 100;
  
  Serial.println(xPortGetCoreID());
  Serial.println("Done");
  vTaskDelay(100 / portTICK_PERIOD_MS);
  }
}

//Task 3-> Preparing data to send to ESP-NOW using Queues
void task3(void *pvParameters) {
    while (true) {
        int adcValue = analogRead(D1);

        String preparedData = String(getPitchValue(1)) + "," +
                              String(getRollValue(1)) + "," +
                              String(getYawValue(1)) + "," +
                              String(getLatitude(1)) + "," +
                              String(getLongitude(1)) + "," +
                              String(getSatelliteCount(1)) + "," +
                              String(getBPM(1)) + "," +
                              String(getAvgBPM(1)) + "," +
                              String(dog_mode) + "," +
                              String(Failsafe_mode) + "," +
                              String(adcValue);

        // Send the data to the queue
        if (xQueueSend(dataQueue, &preparedData, portMAX_DELAY) != pdPASS) {
            Serial.println("Failed to send data to the queue");
        } else {
            Serial.println("Data queued successfully: " + preparedData);
        }

        vTaskDelay(100 / portTICK_PERIOD_MS);
    }
}

//Task 4->sending data through the ESP-NOW
void task4(void *pvParameters) {
    String queueData;

    while (true) {
        if (xQueueReceive(dataQueue, &queueData, portMAX_DELAY) == pdPASS) {
            String preparedData = queueData;

            esp_err_t result = esp_now_send(broadcastAddress, (uint8_t *)preparedData.c_str(), preparedData.length());

            if (result == ESP_OK) {
                Serial.println("Data sent successfully: " + preparedData);

            if(Failsafe_mode==true && enter_flag==false){
                min_x=millis();
                enter_flag=true;
            }

            } else {
                Serial.println("Error sending data: " + String(result));
                esp_restart();  //reset if any sending error occurs
            }
        }
      if(Failsafe_mode==true && (millis()-min_x>4000)){
        failsafe_bool=true;
      }  

    }

    vTaskDelay(100 / portTICK_PERIOD_MS);
}

//task 5->OLED GUI Handling
void task5(void *pvParameters) {

    for (;;) {  
    
        if (!select_flag) {  
            display.clearDisplay();

            if (flag_GUI) {   
                flag_GUI = false; 

                switch (GUI_mode) {
                    case 1:
                        display.drawBitmap(0, 0, enemy_GUI, 128, 64, 1);
                        break;
                    case 2:
                        display.drawBitmap(0, 0, gps_GUI, 128, 64, 1);
                        break;
                    case 3:
                        display.drawBitmap(0, 0, battery_GUI, 128, 64, 1);
                        break;
                    case 4:
                        display.drawBitmap(0, 0, heartbeat_GUI, 128, 64, 1);
                        break;
                }
                  
                display.display();
                vTaskDelay(100 / portTICK_PERIOD_MS);
            } else { 
                switch (GUI_mode) {
                    case 1:
                        display.drawBitmap(0, 0, enemy_GUI, 128, 64, 1);
                        break;
                    case 2:
                        display.drawBitmap(0, 0, gps_GUI, 128, 64, 1);
                        break;
                    case 3:
                        display.drawBitmap(0, 0, battery_GUI, 128, 64, 1);
                        break;
                    case 4:
                        display.drawBitmap(0, 0, heartbeat_GUI, 128, 64, 1);
                        break;
                }
                display.display();  
            }
        } 
        else {  
            display.clearDisplay();
            display.setTextSize(1);
            display.setTextColor(SSD1306_WHITE);

            switch (GUI_mode) {
                case 1:
                    display.setCursor(10, 20);
                    display.println(F("Detected Enemy:"));
                    display.setCursor(103, 20);
                    display.print(enemy_detected);
                    display.setCursor(10, 40 );
                    vTaskDelay(10 / portTICK_PERIOD_MS);
                    
                    display.println(F("Watch Mode:"));
                    display.setCursor(80, 40);
                    display.print(dog_mode);
                    vTaskDelay(10 / portTICK_PERIOD_MS);

                    display.setCursor(10, 55);
                    display.println(F("Remote Mode:"));
                    display.setCursor(85, 55);
                    display.print(mode_remote);

                    break;

                case 2:
                    display.setCursor(10, 10);
                    display.println(F("Latitude:"));
                    display.setCursor(70,10);
                    display.print(getLatitude(1));
                    vTaskDelay(10 / portTICK_PERIOD_MS);

                    display.setCursor(10, 25);
                    display.println(F("Longitude:"));
                    display.setCursor(70,25);
                    display.print(getLongitude(1));
                    vTaskDelay(10 / portTICK_PERIOD_MS);

                    display.setCursor(10, 50);
                    display.println(F("Satellites Conn:"));
                    display.setCursor(110,50);
                    display.print(getSatelliteCount(1));
                    vTaskDelay(10 / portTICK_PERIOD_MS);
                    

                    break;
                case 3:
                    display.setCursor(10, 10);
                    display.println(F("Watch BAtt:"));
                    display.setCursor(95,10);
                    display.print(batteryPercentage);
                    vTaskDelay(10 / portTICK_PERIOD_MS);

                    display.setCursor(10, 25);
                    display.println(F("Remote Batt:"));
                    display.setCursor(100,25);
                    display.print(remotebattery);
                    vTaskDelay(10 / portTICK_PERIOD_MS);

                    display.setCursor(10, 50);
                    display.println(F("POC Batt:"));
                    display.setCursor(100,50);
                    display.print(Pocbattery);
                    vTaskDelay(10 / portTICK_PERIOD_MS);
                    break;

                case 4:
                    display.setCursor(10, 10);
                    display.println(F("IR Val:"));
                    display.setCursor(90,10);
                    display.print(getIRValue(1));
                    vTaskDelay(10 / portTICK_PERIOD_MS);

                    display.setCursor(10, 25);
                    display.println(F("Avg BPM:"));
                    display.setCursor(100,25);
                    display.print(getAvgBPM(1));
                    vTaskDelay(10 / portTICK_PERIOD_MS);

                    display.setCursor(10, 50);
                    display.println(F("BPM:"));
                    display.setCursor(90,50);
                    display.print(getBPM(1));
                    vTaskDelay(10 / portTICK_PERIOD_MS);
                    break;
            }
            display.display();
        }

        vTaskDelay(1000 / portTICK_PERIOD_MS);
    }
}

//Task 6->Premptative Task
void task6(void *pvParameters) {
    for (;;) {
        vTaskDelay(100 / portTICK_PERIOD_MS);
    }
}

//Task 7->FailSafe Mechanism
void task7(void *pvParameters) {
    const int tolerance = 5; // Adjust tolerance for stability check

    while (1) {
        bool isStable = true;

        String firstNodePitchStr = getPitchValue(1);  // Get the pitch value as a String
        String firstNodeRollStr = getRollValue(1);    // Get the roll value as a String
        String firstNodeYawStr = getYawValue(1);      // Get the yaw value as a String

        if (firstNodePitchStr == "" || firstNodeRollStr == "" || firstNodeYawStr == "") {
            Serial.println("Invalid data received from the first node.");
            vTaskDelay(100 / portTICK_PERIOD_MS);
            continue;
        }

        int firstNodePitch = atoi(firstNodePitchStr.c_str());
        int firstNodeRoll = atoi(firstNodeRollStr.c_str());
        int firstNodeYaw = atoi(firstNodeYawStr.c_str());

        // Loop through nodes 2 to 5 to compare their data
        for (int i = 2; i <= 5; i++) {
            String currentPitchStr = getPitchValue(i);
            String currentRollStr = getRollValue(i);
            String currentYawStr = getYawValue(i);

            if (currentPitchStr == "" || currentRollStr == "" || currentYawStr == "") {
                isStable = false;
                Serial.println("Invalid data received from node " + String(i));
                break;
            }

            int currentPitch = atoi(currentPitchStr.c_str());
            int currentRoll = atoi(currentRollStr.c_str());
            int currentYaw = atoi(currentYawStr.c_str());

            if (abs(currentPitch - firstNodePitch) > tolerance ||
                abs(currentRoll - firstNodeRoll) > tolerance ||
                abs(currentYaw - firstNodeYaw) > tolerance) {
                isStable = false; 
                break;  
            }
        }

        if (isStable) {
            // Check BPM on all nodes
                String avgBPMStr = getAvgBPM(1);  

                int avgBPM = atoi(avgBPMStr.c_str());

                if (avgBPM < 25) { 
                    Serial.println("Failsafe triggered");

                    // Trigger failsafe mode
                    Failsafe_mode = true;
                    
                    // Activate failsafe only if it's not activated already
                    if (!failsafe_bool) {
                        // Perform failsafe actions
                        task3(NULL);  
                        task4(NULL);
                        failsafe_bool = true;  // Mark failsafe as activated
                }
            }
        }
        vTaskDelay(2000 / portTICK_PERIOD_MS);  // Delay between checks
    }
  }

//Task 8->handles the failsafe mode 
void task8(void *pvParameters) {
    while(1){
      if(Failsafe_mode==true && failsafe_bool==true){
          display.clearDisplay();
          display.setTextSize(1);
          display.setTextColor(SSD1306_WHITE);
          display.setCursor(20, 30);
          display.println(F("FailSafe Mode"));
          display.display();
          deleteAllTasks();

      }
    }
     vTaskDelay(1000 / portTICK_PERIOD_MS);
}
//--------------------------xxxxxxxxxxxxxxxxx------------------------------


//----------------------------void setup()---------------------------


void setup(){
  Serial.begin(115200);//Hardware Serial
  mySerial.begin(9600);//Software Serial for GPS

  Wire.begin();//I2C Start
  Serial.println("SMART UTILITY WATCH, KRS");

  //pin mode declaration
  pinMode(up_button,INPUT_PULLUP);
  pinMode(down_button,INPUT_PULLUP);
  pinMode(select_button,INPUT_PULLUP);
  pinMode(press_button,INPUT_PULLUP);
  pinMode(ADC,INPUT);
  

  //.including interrupt to the pins
  attachInterrupt(digitalPinToInterrupt(up_button), up_ISR, FALLING);
  attachInterrupt(digitalPinToInterrupt(down_button), down_ISR, FALLING);
  attachInterrupt(digitalPinToInterrupt(select_button), select_ISR, FALLING);
  attachInterrupt(digitalPinToInterrupt(press_button), press_ISR, FALLING);

  //dummy values for GPS
  addNode_GPS("0,0,0");
  addNode_GPS("0,0,0");
  addNode_GPS("0,0,0");
  addNode_GPS("0,0,0");
  addNode_GPS("0,0,0");

  //start OLED display
  if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    Serial.println(F("SSD1306 allocation failed"));
    for(;;);
  }

  delayMicroseconds(100);

  display.clearDisplay();
  display.setTextSize(1); 
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(10, 30);
  display.println(F("Place Your Wrist"));
  display.display(); 
  delay(3000);

  //MAX30102 starts
   if (!particleSensor.begin(Wire, I2C_SPEED_FAST)) //Use default I2C port, 400kHz speed
  {
    Serial.println("MAX30102 was not found");
    while (1);
  }

  particleSensor.setup(); //Configure sensor with default settings
  particleSensor.setPulseAmplitudeRed(0x0A); //Turn Red LED to low to indicate sensor is running
  particleSensor.setPulseAmplitudeGreen(0); //Turn off Green LED

  int time=buffer_time;

  // Take 5 readings in setup, with finger detection
  while(time>0 && beatAvg<40) {
    Serial.println(time);
    Serial.println("\t");
    Serial.println(beatAvg);

    long irValue = particleSensor.getIR();

    if (irValue < 50000) {
      Serial.println("No Wrist detected");
      display.clearDisplay();
      display.setTextSize(1);
      display.setTextColor(SSD1306_WHITE);
      display.setCursor(10, 30);
      display.println(F("Wrist Not Placed"));
      display.display(); 

      while (irValue < 50000) { 
        irValue = particleSensor.getIR();
      }

    }
    else{
      display.clearDisplay();
      display.setTextSize(1);
      display.setTextColor(SSD1306_WHITE);
      display.setCursor(12, 10);
      display.println(F("Wrist Detected, HR: "));
      display.setCursor(65, 50);
      display.println(beatAvg);
      display.display(); 
    }

    irValue = particleSensor.getIR();

  if (checkForBeat(irValue) == true)
  {
    long delta = millis() - lastBeat;
    lastBeat = millis();

    beatsPerMinute = 60 / (delta / 1000.0);

    if (beatsPerMinute < 255 && beatsPerMinute > 20)
    {
      rates[rateSpot++] = (byte)beatsPerMinute;
      rateSpot %= RATE_SIZE;

      beatAvg = 0;
      for (byte x = 0 ; x < RATE_SIZE ; x++)
        beatAvg += rates[x];
      beatAvg /= RATE_SIZE;
    }
  }
    addHeartrateNode(String(irValue), String(beatsPerMinute), String(beatAvg));
    time--;
    yield();
  }
  
  display.clearDisplay();
  delayMicroseconds(10);  
  display.drawBitmap(0, 0, enemy_GUI, 128, 64, 1);
  display.display();

  //mpu initialization
  mpu.initialize();

  if (!mpu.testConnection()) {
    Serial.println("MPU6050 connection failed");
    while (1);
  }

  delayMicroseconds(1000);

    //take 5 initial reading
    for(int i = 0; i < 5; i++) {
        int16_t gyroX, gyroY, gyroZ;
        mpu.getRotation(&gyroX, &gyroY, &gyroZ); 
        float pitch, roll, yaw;
        calculatePitchRollYaw(gyroX, gyroY, gyroZ, pitch, roll, yaw);

        String pitchRollYawData = "Pitch: " + String(pitch, 2) + ", Roll: " + String(roll, 2) + ", Yaw: " + String(yaw, 2);
        addNode_MPU(pitchRollYawData);
        delay(100);  
    }

  //set the wifi mode
  WiFi.mode(WIFI_STA);

  // Init ESP-NOW
  if (esp_now_init() != ESP_OK) {
    Serial.println("Error initializing ESP-NOW");
    return;
  }

  esp_now_register_send_cb(OnDataSent);
  
  // Register peer
  memcpy(peerInfo.peer_addr, broadcastAddress, 6);
  peerInfo.channel = 0;  
  peerInfo.encrypt = false;
  
  // Add peer        
  if (esp_now_add_peer(&peerInfo) != ESP_OK){
    Serial.println("Failed to add peer");
    return;
  }

  // Register for a callback function that will be called when data is received
  esp_now_register_recv_cb(esp_now_recv_cb_t(onDataReceived));

      dataQueue = xQueueCreate(QUEUE_SIZE, sizeof(String));
    if (dataQueue == NULL) {
        Serial.println("Error creating queue");
        return;
    }

  //FreeRTOS

  //Hardware Interrupts
  xTaskCreatePinnedToCore(
    task1,              // Function to be executed
    "Task1",            // Name of the task
    20000,              // Stack size
    NULL,               // Parameters
    1,                  // Priority
    &Task1,             // Task handle
    tskNO_AFFINITY // Core number (0 for Unicore, 1 for Dual-core)
  );


  //Reading sensors
  xTaskCreatePinnedToCore(
    task2,              // Function to be executed
    "Task2",            // Name of the task
    20000,              // Stack size
    NULL,               // Parameters
    3,                  // Priority
    &Task2,             // Task handle
    tskNO_AFFINITY // Core number (0 for Unicore, 1 for Dual-core)
  );

  //Preparing data to send to ESP-NOW using Queues
  xTaskCreatePinnedToCore(
    task3,              // Function to be executed
    "Task3",            // Name of the task
    20000,              // Stack size
    NULL,               // Parameters
    1,                  // Priority
    &Task3,             // Task handle
    tskNO_AFFINITY // Core number (0 for Unicore, 1 for Dual-core)
  );

  //ESP-NOW Send
  xTaskCreatePinnedToCore(
    task4,              // Function to be executed
    "Task4",            // Name of the task
    4096,              // Stack size
    NULL,               // Parameters
    1,                  // Priority
    &Task4,             // Task handle
    tskNO_AFFINITY // Core number (0 for Unicore, 1 for Dual-core)
  );

  //OLED GUI Handling
  xTaskCreatePinnedToCore(
    task5,              // Function to be executed
    "Task5",            // Name of the task
    20000,              // Stack size
    NULL,               // Parameters
    3,                  // Priority
    &Task5,             // Task handle
    tskNO_AFFINITY // Core number (0 for Unicore, 1 for Dual-core)
  );

  //Premptative Task Handling
  xTaskCreatePinnedToCore(
    task6,              // Function to be executed
    "Task6",            // Name of the task
    20000,              // Stack size
    NULL,               // Parameters
    4,                  // Priority
    &Task6,             // Task handle
    tskNO_AFFINITY // Core number (0 for Unicore, 1 for Dual-core)
  );

  //FailSafe Mechanism
  xTaskCreatePinnedToCore(
    task7,              // Function to be executed
    "Task7",            // Name of the task
    20000,              // Stack size
    NULL,               // Parameters
    5,                  // Priority
    &Task7,             // Task handle
    tskNO_AFFINITY // Core number (0 for Unicore, 1 for Dual-core)
  );

  //handles the failsafe mode
  xTaskCreatePinnedToCore(
    task8,              // Function to be executed
    "Task8",            // Name of the task
    4096,              // Stack size
    NULL,               // Parameters
    5,                  // Priority
    &Task8,             // Task handle
    tskNO_AFFINITY // Core number (0 for Unicore, 1 for Dual-core)
  );
}
//--------------------------xxxxxxxxxxxxxxxxx------------------------------

void loop(){
  vTaskDelay(100 / portTICK_PERIOD_MS);
}